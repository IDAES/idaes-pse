#################################################################################
# The Institute for the Design of Advanced Energy Systems Integrated Platform
# Framework (IDAES IP) was produced under the DOE Institute for the
# Design of Advanced Energy Systems (IDAES).
#
# Copyright (c) 2018-2024 by the software owners: The Regents of the
# University of California, through Lawrence Berkeley National Laboratory,
# National Technology & Engineering Solutions of Sandia, LLC, Carnegie Mellon
# University, West Virginia University Research Corporation, et al.
# All rights reserved.  Please see the files COPYRIGHT.md and LICENSE.md
# for full copyright and license information.
#################################################################################
"""
Tests for linear algebra utility methods.
"""

import os
import pytest

import numpy as np
from numpy.linalg import norm, qr
from numpy.random import default_rng
from scipy.sparse import csc_array, load_npz

from pyomo.common.fileutils import this_file_dir
from pyomo.environ import log10

import idaes.logger as idaeslog
from idaes.core.util.linalg import svd_rayleigh_ritz

svd_cache = os.sep.join([this_file_dir(), "svd_cache"])

__author__ = "Douglas Allan"


def _random_svd(
    n_rows: int,
    n_columns: int,
    n_small: int,
    seed: int,
    eps_small: float = 1e-12,
    eps_min: float = 1e-16,
):
    """
    Constructs an n_rows by n_columns Numpy 2D array A from its singular value decomposition
    A = U @ diag(sigma) @ V.T. U and V are created through orthogonalization of random
    arrays. The 1D array sigma is generated such that min(n_rows, n_columns) - n_small
    singular values are greater than eps_small while n_small singular values are less than
    eps_small.

    Args:
        n_rows: Number of rows in outlet array A
        n_columns: Number of columns in outlet array A
        n_small: Number of singular values smaller than eps_small
        seed: Seed for Numpy's random number generator
        eps_small: Value defining threshold for small singular value (default 1e-12)
        eps_min: Smallest singular value possible
    Returns:
        A: Random matrix generated by function
        U: m by number_singular_values dense array of left singular vectors
        svals: 1D dense array of number_singular_values singular values, sorted from smallest to largest
        V: n by number_singular_values dense array of left singular vectors
    """
    n_svals = min(n_rows, n_columns)
    assert n_svals >= n_small
    rng_obj = default_rng(seed)

    U = rng_obj.standard_normal((n_rows, n_svals))
    V = rng_obj.standard_normal((n_columns, n_svals))
    U, _ = qr(U)
    V, _ = qr(V)

    svals_big = rng_obj.uniform(low=log10(eps_small), high=0, size=(n_svals - n_small,))
    svals_big = 10**svals_big
    svals_big.sort()
    svals_small = rng_obj.uniform(
        low=log10(eps_min), high=log10(eps_small), size=(n_small,)
    )
    svals_small = 10**svals_small
    svals_small.sort()
    svals = np.concatenate([svals_small, svals_big])

    A = U @ np.diag(svals) @ V.T

    return A, U, svals, V


def _assert_subspace_containment(U, V, tol=1e-8):
    """
    Asserts that the matrix U is contained in the subspace spanned by
    the orthonormal basis V to an absolute tolerance of tol.
    """
    assert norm(V @ (V.T @ U) - U) == pytest.approx(0, rel=0, abs=tol)


def _test_svd_quality(A, Uhat, svals_hat, Vhat, null_hat=None, nvec=10):
    m, n = A.shape
    abs_tol = 1e-15 * np.sqrt(m * n)
    # First test shapes
    assert Uhat.shape == (m, nvec)
    assert Vhat.shape == (n, nvec)
    assert svals_hat.shape == (nvec,)
    if null_hat is not None:
        # It's highly unlikely, but we may get fewer null vectors than |m - n|
        # so we don't test for that here.
        if m > n:
            assert null_hat.shape[0] == m
        else:
            assert null_hat.shape[0] == n

    # U.T @ A @ V = Sigma
    assert Uhat.T @ A @ Vhat == pytest.approx(np.diag(svals_hat), rel=1e-6, abs=abs_tol)
    # U.T @ A = Sigma @ V.T
    assert norm(Uhat.T @ A, axis=1) == pytest.approx(svals_hat, rel=1e-2, abs=abs_tol)
    # A @ V = U @ Sigma
    assert norm(A @ Vhat, axis=0) == pytest.approx(svals_hat, rel=1e-2, abs=abs_tol)
    if null_hat is not None:
        if m > n:
            assert norm(null_hat.T @ A) == pytest.approx(0, rel=0, abs=abs_tol)
        else:
            assert norm(A @ null_hat) == pytest.approx(0, rel=0, abs=abs_tol)

    # Check orthogonality
    assert Uhat.T @ Uhat == pytest.approx(np.eye(Uhat.shape[1]), rel=0, abs=abs_tol)
    assert Vhat.T @ Vhat == pytest.approx(np.eye(Vhat.shape[1]), rel=0, abs=abs_tol)
    if null_hat is not None:
        assert null_hat.T @ null_hat == pytest.approx(
            np.eye(null_hat.shape[1]), rel=0, abs=abs_tol
        )
        if m > n:
            assert norm(null_hat.T @ Uhat) == pytest.approx(0, abs=abs_tol)
        else:
            assert norm(null_hat.T @ Vhat) == pytest.approx(0, abs=abs_tol)


class TestSVDRayleighRitz:
    @pytest.mark.unit
    def test_not_sparse(self):
        A = np.eye(2)
        with pytest.raises(
            ValueError,
            match="This method expects a Scipy sparse array-like as an input but was passed "
            "a dense array-like instead. Try using scipy.linalg.svd for a dense SVD method.",
        ):
            svd_rayleigh_ritz(A)

    @pytest.mark.unit
    def test_not_2D(self):
        A = np.zeros((2, 3, 4))
        with pytest.raises(
            ValueError,
            match="This method expects a 2D Scipy sparse array-like as input, but was passed "
            "a 3D array-like instead.",
        ):
            svd_rayleigh_ritz(A)

    @pytest.mark.unit
    def test_not_converged(self):
        A = np.eye(2)
        with pytest.raises(
            RuntimeError,
            match="Rayleigh-Ritz iteration did not converge! Consider increasing "
            "the tolerance or maximum number of iterations.",
        ):
            svd_rayleigh_ritz(csc_array(A), max_iter=0)

    @pytest.mark.unit
    def test_square(self):
        A, _, svals, _ = _random_svd(
            n_rows=30, n_columns=30, n_small=5, seed=7, eps_min=1e-16
        )
        svals_trunc = svals[:10]
        Uhat, svals_hat, Vhat = svd_rayleigh_ritz(csc_array(A), seed=1)
        _test_svd_quality(A, Uhat, svals_hat, Vhat)
        assert pytest.approx(svals_trunc, rel=1e-4, abs=1e-14) == svals_hat

    @pytest.mark.unit
    def test_overdetermined(self):
        A, _, svals, _ = _random_svd(
            n_rows=35, n_columns=30, n_small=5, seed=8, eps_min=1e-16
        )
        svals_trunc = svals[:10]
        Uhat, svals_hat, Vhat, null_hat = svd_rayleigh_ritz(csc_array(A), seed=2)
        _test_svd_quality(A, Uhat, svals_hat, Vhat, null_hat)
        assert pytest.approx(svals_trunc, rel=1e-4, abs=1e-14) == svals_hat

    @pytest.mark.unit
    def test_underdetermined(self):
        A, _, svals, _ = _random_svd(
            n_rows=30, n_columns=35, n_small=5, seed=9, eps_min=1e-16
        )
        svals_trunc = svals[:10]
        Uhat, svals_hat, Vhat, null_hat = svd_rayleigh_ritz(csc_array(A), seed=3)
        _test_svd_quality(A, Uhat, svals_hat, Vhat, null_hat)
        assert pytest.approx(svals_trunc, rel=1e-4, abs=1e-14) == svals_hat

    @pytest.mark.unit
    def test_underdetermined_warning(self, caplog):
        A, _, svals, _ = _random_svd(
            n_rows=30, n_columns=45, n_small=5, seed=13, eps_min=1e-16
        )
        svals_trunc = svals[:10]
        with caplog.at_level(idaeslog.WARNING):
            Uhat, svals_hat, Vhat, null_hat = svd_rayleigh_ritz(csc_array(A), seed=3)
        assert (
            "Matrix A has a nullspace of dimension at least 15, which "
            "degrades the efficiency of SVD algorithms based on the augmented "
            "matrix [[0, A.T], [A, 0]]."
        ) in caplog.text

        _test_svd_quality(A, Uhat, svals_hat, Vhat, null_hat)
        assert pytest.approx(svals_trunc, rel=1e-4, abs=1e-14) == svals_hat

    @pytest.mark.unit
    def test_overdetermined_warning(self, caplog):
        A, _, svals, _ = _random_svd(
            n_rows=44, n_columns=30, n_small=5, seed=23, eps_min=1e-16
        )
        svals_trunc = svals[:10]
        with caplog.at_level(idaeslog.WARNING):
            Uhat, svals_hat, Vhat, null_hat = svd_rayleigh_ritz(csc_array(A), seed=3)
        assert (
            "Matrix A has a left nullspace of dimension at least 14, which "
            "degrades the efficiency of SVD algorithms based on the augmented "
            "matrix [[0, A.T], [A, 0]]."
        ) in caplog.text

        _test_svd_quality(A, Uhat, svals_hat, Vhat, null_hat)
        assert pytest.approx(svals_trunc, rel=1e-4, abs=1e-14) == svals_hat

    @pytest.mark.unit
    def test_underdetermined_small(self):
        A, _, svals, _ = _random_svd(
            n_rows=5, n_columns=6, n_small=1, seed=657457, eps_min=1e-16
        )
        svals_trunc = svals
        # The default option is 10 singular vectors, but the method is supposed to silently
        # truncate it to 5 singular vectors
        Uhat, svals_hat, Vhat, null_hat = svd_rayleigh_ritz(csc_array(A), seed=12342314)
        _test_svd_quality(A, Uhat, svals_hat, Vhat, null_hat, nvec=5)
        assert pytest.approx(svals_trunc, rel=1e-4, abs=1e-14) == svals_hat

    @pytest.mark.unit
    def test_overdetermined_small(self):
        A, _, svals, _ = _random_svd(
            n_rows=6, n_columns=5, n_small=1, seed=4321412, eps_min=1e-16
        )
        svals_trunc = svals
        # The default option is 10 singular vectors, but the method is supposed to silently
        # truncate it to 5 singular vectors
        Uhat, svals_hat, Vhat, null_hat = svd_rayleigh_ritz(csc_array(A), seed=3425767)
        _test_svd_quality(A, Uhat, svals_hat, Vhat, null_hat, nvec=5)
        assert pytest.approx(svals_trunc, rel=1e-4, abs=1e-14) == svals_hat

    @pytest.mark.unit
    def test_square_small(self):
        A, _, svals, _ = _random_svd(
            n_rows=5, n_columns=5, n_small=1, seed=5463, eps_min=1e-16
        )
        svals_trunc = svals
        # The default option is 10 singular vectors, but the method is supposed to silently
        # truncate it to 5 singular vectors
        Uhat, svals_hat, Vhat = svd_rayleigh_ritz(csc_array(A), seed=9876575)
        _test_svd_quality(A, Uhat, svals_hat, Vhat, nvec=5)
        assert pytest.approx(svals_trunc, rel=1e-4, abs=1e-14) == svals_hat

    @pytest.mark.unit
    def test_more_svs(self):
        A, _, svals, _ = _random_svd(
            n_rows=30, n_columns=35, n_small=5, seed=12, eps_min=1e-16
        )
        svals_trunc = svals[:12]
        Uhat, svals_hat, Vhat, null_hat = svd_rayleigh_ritz(
            csc_array(A), number_singular_values=12, seed=31
        )
        _test_svd_quality(A, Uhat, svals_hat, Vhat, null_hat, nvec=12)
        assert pytest.approx(svals_trunc, rel=1e-4, abs=1e-14) == svals_hat

    @pytest.mark.unit
    def test_fewer_svs(self):
        A, _, svals, _ = _random_svd(
            n_rows=30, n_columns=35, n_small=5, seed=37, eps_min=1e-16
        )
        svals_trunc = svals[:7]
        Uhat, svals_hat, Vhat, null_hat = svd_rayleigh_ritz(
            csc_array(A), number_singular_values=7, seed=31
        )
        _test_svd_quality(A, Uhat, svals_hat, Vhat, null_hat, nvec=7)
        assert pytest.approx(svals_trunc, rel=1e-4, abs=1e-14) == svals_hat

    @pytest.mark.component
    def test_soc_overdetermined(self):
        jac = load_npz(os.sep.join([svd_cache, "overdetermined_soc_jac.npz"]))
        # "Truth" values come from a dense svd of the matrix
        cached_svd = np.load(
            os.sep.join([svd_cache, "overdetermined_soc_svd.npz"]), allow_pickle=False
        )
        Utrue = cached_svd["Utrue"]
        svals_true = cached_svd["svals_true"]
        Vtrue = cached_svd["Vtrue"]
        null_true = cached_svd["null_true"]

        Uhat, svals_hat, Vhat, null_hat = svd_rayleigh_ritz(jac, seed=86)
        _test_svd_quality(jac, Uhat, svals_hat, Vhat, null_hat)
        _assert_subspace_containment(Uhat, Utrue)
        _assert_subspace_containment(Vhat, Vtrue)
        _assert_subspace_containment(null_hat, null_true)
        assert pytest.approx(svals_true, rel=1e-4, abs=1e-14) == svals_hat

    @pytest.mark.integration
    def test_soc_underdetermined(self):
        jac = load_npz(os.sep.join([svd_cache, "underdetermined_soc_jac.npz"]))
        # "Truth" values come from a dense svd of the matrix
        cached_svd = np.load(
            os.sep.join([svd_cache, "underdetermined_soc_svd.npz"]), allow_pickle=False
        )
        Utrue = cached_svd["Utrue"]
        svals_true = cached_svd["svals_true"]
        Vtrue = cached_svd["Vtrue"]
        null_true = cached_svd["null_true"]

        Uhat, svals_hat, Vhat, null_hat = svd_rayleigh_ritz(jac, seed=86, max_iter=200)
        _test_svd_quality(jac, Uhat, svals_hat, Vhat, null_hat)
        _assert_subspace_containment(Uhat, Utrue)
        _assert_subspace_containment(Vhat, Vtrue)
        _assert_subspace_containment(null_hat, null_true)
        assert pytest.approx(svals_true, rel=1e-4, abs=1e-14) == svals_hat

    @pytest.mark.integration
    def test_mea_column_overdetermined(self):
        jac = load_npz(os.sep.join([svd_cache, "overdetermined_mea_column_jac.npz"]))
        # "Truth" values come from a dense svd of the matrix
        # However, with this seed, we do not converge to the 10 smallest singular
        # values, but only 9 of them plus the 11th(?) smallest sval

        Uhat, svals_hat, Vhat, null_hat = svd_rayleigh_ritz(jac, seed=42, max_iter=200)
        _test_svd_quality(jac, Uhat, svals_hat, Vhat, null_hat)

    @pytest.mark.integration
    def test_mea_column_underdetermined(self):
        jac = load_npz(os.sep.join([svd_cache, "underdetermined_mea_column_jac.npz"]))
        # "Truth" values come from a dense svd of the matrix
        # We've got the smallest 20 singular vectors saved, so we can test subspace containment here
        cached_svd = np.load(
            os.sep.join([svd_cache, "underdetermined_mea_column_svd.npz"]),
            allow_pickle=False,
        )
        Utrue = cached_svd["Utrue"]
        Vtrue = cached_svd["Vtrue"]
        null_true = cached_svd["null_true"]

        Uhat, svals_hat, Vhat, null_hat = svd_rayleigh_ritz(jac, seed=87, max_iter=200)
        _test_svd_quality(jac, Uhat, svals_hat, Vhat, null_hat)
        _assert_subspace_containment(Uhat, Utrue)
        _assert_subspace_containment(Vhat, Vtrue)
        _assert_subspace_containment(null_hat, null_true)

    @pytest.mark.integration
    def test_big_mea_column_square(self):
        jac = load_npz(os.sep.join([svd_cache, "square_big_mea_column_jac.npz"]))
        # "Truth" values come from a dense svd of the matrix
        cached_svd = np.load(
            os.sep.join([svd_cache, "square_big_mea_column_svd.npz"]),
            allow_pickle=False,
        )
        Utrue = cached_svd["Utrue"]
        Vtrue = cached_svd["Vtrue"]

        Uhat, svals_hat, Vhat = svd_rayleigh_ritz(jac, seed=87, max_iter=200)
        _test_svd_quality(jac, Uhat, svals_hat, Vhat)
        _assert_subspace_containment(Uhat, Utrue, tol=1e-6)
        _assert_subspace_containment(Vhat, Vtrue, tol=1e-6)
